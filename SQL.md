Введение и базовые операции SQL

Основные понятия БД
Сущность - класс, хранящийся в базе данных, таблица.
Объект - экземпляр сущности.
Атрибут - свойства характеризующие сущность, название столбца в
таблице.
Кортеж - строка в таблице, набор значений конкретных атрибутов.
Домен - набор допустимых значений атрибута.
Идентификатор - атрибут с уникальным значением для данной таблицы

СУБД:
- MySQL - доминирующая РСУБД среди свободного ПО
- MongoDB - наиболее популярная документоориентированная СУБД
- Redis - наиболее стабильная СУБД типа “ключ-значение”

Проектирование:
- MySQL Workbench - популярный и свободный инструмент выполнения
запросов и проектирования БД
-  Django ORM - на любом популярном языке есть несколько вариантов

Архитектура СУБД
Основные компоненты:
- Ядро - процессы, сеть, память, файловая система и т.д.
- Диспетчер данных - транзакции, кэш
- Диспетчер запросов - парсер запроса, оптимизатор, исполнитель
- Набор инструментов для служебных операций - резервное
копирование, восстановление, мониторинг

Язык SQL
Диалекты:
- Oracle  для высоконагруженных и сложных СУБД
- MySQL основная СУБД для web разработки
- PostgreSQL  постреляционная СУБД
- MS SQL  на базе windows
- SQLite  для приложений на отдельных машинах
- Access  альтернатива SQLite от MS

Персистентность - долговременность хранения данных

Агрегация данных

Один из наиболее мощных инструментов для работы с данными это "Агрегация данных"
АД нужна для того чтобы сформировать отчеты
Например: суммировать или посчитать количество элементов для различных условий
сгруппировать статистику по различным значениям атрибутов
В качестве пример База услуг компании
Одна таблица с полями:
-название проекта
-имя клиента
-срок начала
-срок сдачи
-бюджет
```
USE project_simple;
SELECT COUNT(1)-кол-во строк в таблице FROM project;
SELECT AVG(budget) - средний бюджет таблицы FROM project;
Показывает сколько в среднем дней уходит на выполнение проекта
SELECT
    AVG(DATEDIFF(project_finish,project_start))  - вычисление среднего значения и показывает разницу между двумя датами
    MAX(DATEDIFF(project_finish,project_start)) - макс длительность проекта в днях
    MIN(DATEDIFF(project_finish,project_start)) - мин длительность проекта
FROM project WHERE project_finish - отсекает не заканчивающиеся проекты is not null;
Группировка данных GROUP BY
SELECT
    AVG(DATEDIFF(project_finish,project_start)) as avg_days  - вычисление среднего значения и показывает разницу между двумя датами в днях
    MAX(DATEDIFF(project_finish,project_start)) as max_days - макс длительность проекта в днях
    MIN(DATEDIFF(project_finish,project_start)) as min_days - мин длительность проекта в днях
    client_name
FROM project WHERE project_finish - отсекает не заканчивающиеся проекты is not null
group by client_name - получаем имя клиента
order by max_days DESC - сортировка по убыванию в обратном порядке
LIMIT 10; - первые 10 записей
```
Функция Описание
```
COUNT(*) Возвращает количество строк источника записей.
COUNT(<имя поля>) Возвращает количество значений в указанном столбце.
SUM(<имя поля>) Возвращает сумму значений в указанном столбце.
AVG(<имя поля>) Возвращает среднее значение в указанном столбце.
MIN(<имя поля>) Возвращает минимальное значение в указанном столбце.
MAX(<имя поля>) Возвращает максимальное значение в указанном столбце.
 и уже есть подсказка, внимательные и заинтересованные поймут и голову ломать не придётся.
```

Команда для предсавления СУБД
`describe проект.таблица;`

Архитектура ANSI-SPARC (также трёхуровневая архитектура) определяет принцип, согласно которому рекомендуется строить системы управления базами данных (СУБД).
Проект архитектуры был выдвинут в 1975 году подкомитетом SPARC ANSI.
Три уровня системы:
1. Внешний (пользовательский)
2. Промежуточный (концептуальный)
3. Внутренний (физический).
В основе архитектуры ANSI-SPARC лежит концептуальный уровень. В современных СУБД он может быть реализован при помощи представления. Концептуальный уровень описывает данные и их взаимосвязи с наиболее общей точки зрения, — концепции архитекторов базы, используя реляционную или другую модель.
Внутренний уровень позволяет скрыть подробности физического хранения данных (носители, файлы, таблицы, триггеры …) от концептуального уровня. Отделение внутреннего уровня от концептуального обеспечивает так называемую физическую независимость данных.
На внешнем уровне описываются различные подмножества элементов концептуального уровня для представлений данных различным пользовательским программам. Каждый пользователь получает в своё распоряжение часть представлений о данных, но полная концепция скрыта. Отделение внешнего уровня от концептуального обеспечивает логическую независимость данных.
*****
Запросы из нескольких таблиц. Виды соединений
Введение в базы данных. Основы реляционных БД 12.05.16
● Декартово произведение: CROSS JOIN  (применяются достаточно редко)
● Внутреннее соединение: INNER JOIN
● Левое и правое внешнее соединение: LEFT OUTER JOIN, RIGHT OUTER
JOIN
● Полное внешнее соединение: FULL OUTER JOIN
● Естественное соединение: NATURAL JOIN

```
SELECT * from product, category;
          =
SELECT * from product CROSS JOIN category;
```
Выборки из нескольких источников
```
1.SELECT * FROM product INNER JOIN category ON product.category_id = category.category_id;  
2.SELECT product.product_name, category.category_name, product.price
    FROM product INNER JOIN category ON product.category_id = category.category_id;
3.SELECT p.product_name, c.category_name, p.price
        FROM product AS p INNER JOIN category AS c ON p.category_id = c.category_id;
```
Выведите все позиций списка товаров принадлежащие какой-либо категории с названиями товаров и названиями категорий. Список должен быть отсортирован по названию товара, названию категории. Для соединения таблиц необходимо использовать оператор
```
SELECT gd.name, ct.name
        FROM category AS ct
        INNER JOIN category_has_good AS chg ON ct.id = chg.category_id
        INNER JOIN good AS gd ON chg.good_id = gd.id
        ORDER BY gd.name, ct.name;
```
Выведите список клиентов (имя, фамилия) и количество заказов данных клиентов, имеющих статус "new".
```
SELECT cl.first_name, cl.last_name, count(1)
        FROM client AS cl
        INNER JOIN sale AS sl ON cl.id = sl.client_id
        INNER JOIN status AS s ON sl.status_id = s.id
        WHERE s.name = 'new' group by cl.first_name, cl.last_name ORDER BY cl.first_name, cl.last_name ;
```
Выведите список товаров с названиями товаров и названиями категорий, в том числе товаров, не принадлежащих ни одной из категорий.
```
SELECT gd.name, cat.name
        FROM good AS gd
        LEFT OUTER JOIN category_has_good AS chg ON gd.id =chg.good_id
        LEFT OUTER JOIN category AS cat ON cat.id = chg.category_id
        ORDER BY gd.name, cat.name;
```
Выведите список товаров с названиями категорий, в том числе товаров, не принадлежащих ни к одной из категорий, в том числе категорий не содержащих ни одного товара.
```
SELECT gd.name, cat.name
                FROM good AS gd
                LEFT OUTER JOIN category_has_good AS chg ON gd.id = chg.good_id
                LEFT OUTER JOIN category AS cat ON cat.id = chg.category_id
UNION
SELECT gd.name, cat.name
                FROM good AS gd
                right OUTER JOIN category_has_good AS chg ON gd.id =chg.good_id
                right OUTER JOIN category AS cat ON cat.id = chg.category_id;
```
Выведите список всех источников клиентов и суммарный объем заказов по каждому источнику. Результат должен включать также записи для источников, по которым не было заказов.
```
SELECT sr.name, sum(sl.sale_sum)
        FROM source AS sr
        Left OUTER JOIN client AS cl ON cl.source_id = sr.id
        LEFT OUTER JOIN sale AS sl ON cl.id = sl.client_id
		group by sr.name;
```
Выведите названия товаров, которые относятся к категории 'Cakes' или фигурируют в заказах текущий статус которых 'delivering'. Результат не должен содержать одинаковых записей. В запросе необходимо использовать оператор UNION для объединения выборок по разным условиям.
```
SELECT gd.name
        FROM good AS gd
        INNER JOIN category_has_good AS chg ON gd.id =chg.good_id
        INNER JOIN category AS cat ON cat.id = chg.category_id
        where cat.name = 'Cakes'
UNION
SELECT gd.name
		from good as gd
        INNER JOIN sale_has_good AS shg ON gd.id = shg.good_id
        INNER JOIN sale AS sl ON shg.sale_id = sl.id
        INNER JOIN status AS st ON sl.status_id = st.id
        where st.name = 'delivering';
```
Выведите список всех категорий продуктов и количество продаж товаров, относящихся к данной категории. Под количеством продаж товаров подразумевается суммарное количество единиц товара данной категории, фигурирующих в заказах с любым статусом.
```
SELECT ct.name, count(sl.number)
        FROM category AS ct
		LEFT OUTER JOIN category_has_good AS chg ON ct.id = chg.category_id
        LEFT OUTER JOIN  good AS gd ON chg.good_id = gd.id
        LEFT OUTER JOIN sale_has_good AS shg ON gd.id = shg.good_id
        LEFT OUTER JOIN sale AS sl ON shg.sale_id = sl.id
        group by ct.name;
```
Выведите список источников, из которых не было клиентов, либо клиенты пришедшие из которых не совершали заказов или отказывались от заказов. Под клиентами, которые отказывались от заказов, необходимо понимать клиентов, у которых есть заказы, которые на момент выполнения запроса находятся в состоянии 'rejected'. В запросе необходимо использовать оператор UNION для объединения выборок по разным условиям.
```
SELECT sr.name
        FROM source AS sr
        Left OUTER JOIN client AS cl ON cl.source_id = sr.id
        LEFT OUTER JOIN sale AS sl ON cl.id = sl.client_id
        where cl.id is NULL
UNION
SELECT sr.name
        FROM source AS sr
        LEFT OUTER JOIN client AS cl ON cl.source_id = sr.id
        LEFT OUTER JOIN sale AS sl ON cl.id = sl.client_id
        LEFT OUTER JOIN status AS st ON sl.status_id = st.id
        where st.name = 'rejected';
```

***
Процедурные расширения языка SQL
SQL/PSM
- Операторы SQL/DDL, SQL/DML
- Определения и вызовы функций и процедур
- Управляющие конструкции, состояния
Процедурные расширения SQL
Использование:
● Хранимые процедуры
● Триггеры - инициирующие операции
Вариативность:
● Индивидуальность языка каждой СУБД
● Типизация, назначение прав
● Организация выполнения

Функциональная зависимость описывает связь между атрибутами.
Если в отношении один атрибут функционально зависит от другого, то каждое значение первого атрибута связано только с одним значением второго.

Детерминант - атрибут, от которого полностью функционально зависит некоторый другой атрибут.

Полная функциональная зависимость.
Первая нормальная форма - В отношении атрибут В полностью функц зависит от атрибута А, если:
- В функционально зависит от полного значения А.
- В не зависит от подмножества полного значения А.
Вторая нормальная форма:
- Отношение находится в 1НФ
- Каждый атрибут, не входящий в первичный ключ, полностью функционально зависит от первичного ключа.
Третья НФ:
- Находится в 2НФ.
- Нет атрибутов, не входящих в первичный ключ, которые находятся в транзитивной зависимости(А-В, В-С) от первичного ключа. Все атрибуты зависят только от первичного ключа напрямую.
Нормальная форма Бойса-Кодда:
- находится в 3НФ.
- каждый детерминант является потенциальным ключом.

CAP-теорема для нереляционных БД(для распределенных систем можно выбрать только 2 свойства в ущерб третьему):
Consistency - информация на разных узлах согласована
Acailability - система отвечает на запросы
Partition tolerance - связи между узлами могут обрываться

BASE-архитектура
● Basically Available - сбой узла приводит к отказу только для части пользователей
● Soft-state - система может находиться в неусточивом состоянии
● Eventual Consistency - когда-нибудь согласуется

Классы NoSQL
● Ключ-значение - быстрый доступ к данным по ключу
● Документоориентированные - удобство моделирования вложенных структур без жесткой схемы
● Семейство столбцов - таблицы с множеством незаполненных атрибутов (разреженная матрица)
Классы могут пересекаться.

Ключ-значение
Используется для:
● Работы данными в реальном времени
● Кэширования результатов долгих операций
● Файловые системы на основе “ключ-значение”
Примеры СУБД: Berkeley DB, Redis, Memcache

Документоориентированные
Используются для:
● Хранения документов и поиска по ним
● Информационные сервисы
● Данные с нечеткой схемой
Примеры: MongoDB, CouchDB

Семейство столбцов
Используется для:
● Хранение данных, собранных с веб-страниц
● Хранение и поиск по большому объему данных
Примеры: Cassandra, HBase
******
Redis
● 100k операций в секунду для одного узла
● Всего больше сотни команд
● Все команды работы с данными по крайне мере содержат ключ
● Для каждого типа данных свой набор CRUD-команд, различаются
префиксами, например: LPOP, SPOP

Типы данных Redis(ключ-значение)
Ключи: уникальная строка(ключ) для одного набора данных(значение)
Значения(типы данных):
● Строки - скалярные значения, для разных подтипов есть разные операции
● Хэши - для хэш-таблиц внутри значений
● Списки - как list в Python с теми же операциями
● Множества - как set в Python с теми же операциями
● Упорядоченные множества

Репликация в Redis(механизм масштабирования)
● Обновления поступают не только от мастера, но и от уже обновленных слейвов, децентрализуя операцию
● Изменения всегда просты (с одним ключом), поэтому передаются значения, а не операторы

Подписки (PubSub)
Не нужно каждый раз спрашивать, есть ли новые данные, сервер сам пройдется по активным подписчикам и отправит им изменения, когда они появятся.


******
Особенности MongoDB
● Самая популярная ⇒ самая стабильная
● Простота хранения данных ⇒ нет проблем с миграциями
● Сложность восприятия запросов, но легко писать интерпретаторы и генераторы ⇒ разнообразие ORM

Пользовательские команды
Все параметры операций - валидный JSON:
● Сложность восприятия: скобки, нет многих символов
● Легко найти драйвер с подходящим синтаксисом в любом языке

Что есть вместо JOIN
● Ссылки и списки ссылок на объекты
● Встроенные документы, денормализация
● Тип DBRef для драйверов

Репликация такая же как и в Redis, за исключением:
В MongoDB обмен изменениями происходит только с участием master-узла
В MongoDB есть встроенный механизм решения проблем с отказом master-узла
.
